In programming (specifically Python/FastAPI), a standard def function does block execution until all operations within it are finished, while async def does not block. 
Here is a breakdown of how they behave:
def (Synchronous): When you call a def function, the program waits for that function to complete all its operations (e.g., file reading, database queries) before moving to the next line of code. If it performs slow Input/Output (I/O) operations, it blocks the entire thread, preventing other tasks from running.
async def (Asynchronous): This defines a coroutine. It allows the function to "pause" (await) when it hits a slow operation, releasing control back to the system to do other work in the meantime. The function only resumes when the awaited task finishes.
FastAPI Specifics: If you define a path operation with a regular def, FastAPI runs it in an external threadpool so it doesn't block the main server. However, async def is generally preferred for I/O-bound tasks to maximize performance. 
Key Takeaway: If your function performs long-running, non-blocking tasks, async def with await is used to allow other operations to continue in the background. A standard def will wait for everything to finish. 

if we have something like:

async def func():
  response = call_api()
  return response

will this wait for resonse from api?

In your example, the function will wait for the response, but it will do so in a way that is "dangerous" for an asynchronous program. 
How it behaves:
It Blocks the Event Loop: If call_api() is a standard synchronous function (like requests.get), it will pause your entire program.
No Concurrency: While it is waiting for that response, no other tasks in your program can run. The "async" benefit is lost because you didn't use await to tell Python it's okay to do other work while waiting.
Sequential Execution: The line response = call_api() will run just like normal codeâ€”it won't move to the return line until the API data is fully received.

In Python, if you call an async def function without await, the code inside will not wait for responses because the code never even runs. 
1. The Python Behavior: "Fire-and-Nothing"
Unlike JavaScript (where a function starts running immediately until it hits an await), simply calling a Python coroutine function like my_async_func() does two things: 
It creates a coroutine object (a "promise" of future work).
It returns that object to you immediately without executing a single line of code inside the function. 
Because the code hasn't started, it definitely isn't waiting for any network or database responses. 
2. If you use asyncio.create_task() (True Fire-and-Forget)
If your goal is to start the operation but not wait for it to finish, you must wrap it in a task: 
Execution: asyncio.create_task(my_async_func()) schedules the function to run on the event loop as soon as possible.
Wait Behavior: Your main code will continue to the next line immediately. It does not wait for the task's response.
Risk: If your main program finishes before the task does, the task may be killed before it ever gets its response. 

so this is tored in the site generated by fastapi server means - http://127.0.0.1:8000 

Yes, exactly! Because your FastAPI server is running at http://127.0.0.1:8000, the browser "attaches" that cookie specifically to that origin (the combination of http, 127.0.0.1, and 8000).

Here is how the browser manages it:

Host-Only Storage: By default, if you don't specify a domain, the browser stores it as a "host-only" cookie. This means it will only be sent to 127.0.0.1.

Isolation: If you open another tab and go to google.com, the browser will not show or send your FastAPI cookie there.

127.0.0.1 vs localhost: Interestingly, most browsers treat 127.0.0.1 and localhost as different origins. If you set a cookie while visiting 127.0.0.1:8000, it won't show up if you switch the URL to localhost:8000!

Seeing it in action
Since you are developing locally, you can verify this right now:

Open your browser to http://127.0.0.1:8000/docs.

Press F12 to open the Developer Tools.

Go to the Application tab (Chrome/Edge) or Storage tab (Firefox).

Click on Cookies on the left.

You should see your session_id listed there under the 127.0.0.1 domain.