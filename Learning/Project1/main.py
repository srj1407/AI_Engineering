from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
import asyncio
from sqlalchemy import update

class TaskCreate(BaseModel):
    task_name: str

async def run_heavy_logic(task_id: int):
    # 1. Get a fresh session for the background work
    async with SessionLocal() as db:
        try:
            # 2. Update status to "running"
            await db.execute(
                update(Task).where(Task.id == task_id).values(status="running")
            )
            await db.commit()

            # 3. Simulate the "Heavy Work" 
            await asyncio.sleep(10) 
            result_data = f"Process completed for task {task_id}"

            # 4. Success! Update status and save result
            await db.execute(
                update(Task).where(Task.id == task_id).values(
                    status="completed", 
                    result=result_data
                )
            )
        except Exception as e:
            # 5. Failure! Save the error message
            await db.execute(
                update(Task).where(Task.id == task_id).values(
                    status="failed", 
                    error=str(e)
                )
            )
        finally:
            await db.commit()

@app.post("/tasks")
async def create_task(task_data: TaskCreate, db: AsyncSession = Depends(get_db), background_tasks: BackgroundTasks):
    # 1. Create a new record in the "created" state
    new_task = Task(task_name=task_data.task_name, status="created")
    
    # 2. Add and Commit to Postgres
    db.add(new_task)
    await db.commit()
    await db.refresh(new_task) # This gives us the ID generated by Postgres
    
    # 3. Hand off the ID to the background logic (to be built next!)
    background_tasks.add_task(run_heavy_logic, new_task.id)
    
    return {"task_id": new_task.id}

@app.get("/tasks/{task_id}")
async def get_task_status(task_id: int, db: AsyncSession = Depends(get_db)):
    # Look for the task in the Pantry
    stmt = select(Task).where(Task.id == task_id)
    result = await db.execute(stmt)
    task = result.scalar_one_or_none()
    
    # Handle the "Not Found" case
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
        
    return task